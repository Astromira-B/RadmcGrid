#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jun 27 14:33:27 2025

@author: abouikni
"""

import os
import sys
import numpy as np
import radmc3dPy
import subprocess
import matplotlib.pyplot as plt
import multiprocessing
import matplotlib.pylab as plb
from astropy.io import fits
from scipy import interpolate
from radmc3dPy import *
import seaborn as sns  # For pastel color palettes
import subprocess
import shutil
from astropy import constants as const
from tqdm import tqdm
from concurrent.futures import ProcessPoolExecutor, as_completed
from itertools import product  
#########################################################################################################################################################################
#########################################################################################################################################################################
# Usefull fuctions
#########################################################################################################################################################################
#########################################################################################################################################################################

#sublimtion radius
L_sun = 3.828e26
R_sun = 6.957e8
sigma = 5.67e-8
au    = 1.49e11
kappa_lambda = 4.237649e2
def Luminosity(Rstar, tstar):
    R_star = Rstar * R_sun 
    L = 4 * np.pi * sigma * (R_star)**2 *(tstar)**4
    return L

#########################################################################################################################################################################
#########################################################################################################################################################################
# continuous disk
#########################################################################################################################################################################
#########################################################################################################################################################################
def nogap(sim_name, rin, rdisk1, mdisk1, output_dir, core_range,
          tstar, rstar, inc, npix, sizeau, nlmin, nlmax, nlam, Cdelt3, dpc, composition_name, template_dir,
          optional_params=None):
    if optional_params is None:
        optional_params = {}

    allowed_keys = {'nx', 'nz', 'xres_nstep', 'xres_nspan', 'xres_nlev', 'sigma_type',
                    'plsig1', 'plh', 'scattering_mode_max', 'nphot', 'nphot_scat',
                    'nphot_spec', 'dustkappa_ext', 'binary', 'nw', 'wbound'}

    for key in optional_params:
        if key not in allowed_keys:
            raise ValueError(f"Optional parameter '{key}' is not recognized by the setup.")

    nx = optional_params.get('nx', '[100, 100]')
    nz = optional_params.get('nz', '0')
    xres_nstep = optional_params.get('xres_nstep', '3')
    xres_nspan = optional_params.get('xres_nspan', '3')
    xres_nlev = optional_params.get('xres_nlev', '3')
    sigma_type = optional_params.get('sigma_type', '0')
    plsig1 = optional_params.get('plsig1', '-1')
    plh = optional_params.get('plh', '0')
    scattering_mode_max = optional_params.get('scattering_mode_max', '0')
    nphot = optional_params.get('nphot', '1e6')
    nphot_scat = optional_params.get('nphot_scat', '1e6')
    nphot_spec = optional_params.get('nphot_spec', '10000')
   # dustkappa_ext = optional_params.get('dustkappa_ext', "['full_astrosil_amira']")
    binary = optional_params.get('binary', False)
    nw = optional_params.get('nw', '[10,40,30,20]')
    wbound = optional_params.get('wbound', '[0.1, 1.0, 10., 25., 1e3]')

    original_dir = os.getcwd()
    os.makedirs(output_dir, exist_ok=True)

    # template_dir = "/data/users/abo/test_radmc"
    file_to_copy = f"dustkappa_{composition_name}.inp"
    src_file = os.path.join(template_dir, file_to_copy)

    if os.path.isfile(src_file):
        shutil.copy(src_file, output_dir)
    else:
        print(f"Warning: {file_to_copy} not found in {template_dir}")
    if not os.path.isdir(template_dir):
        raise ValueError(f"Template directory '{template_dir}' does not exist.")

    log_path = os.path.join(output_dir, "log.txt")
    with open(log_path, "w") as log_file:
        log_file.write(f"Simulation: {sim_name}\n")
        log_file.write(f"rin: {rin}, rdisk1: {rdisk1}, mdisk1: {mdisk1}, tstar:{tstar}, rstar:{rstar}, inc:{inc}, npix:{npix}, sizeau:{sizeau}, nlmin:{nlmin}, nlmax:{nlmax}, nlam:{nlam}\n")
        log_file.write(f"core_range: {core_range}\n")

    os.chdir(output_dir)

    try:
        models.getModelNames()
        models.getModelDesc('ppdisk')
        analyze.writeDefaultParfile('ppdisk')
        par = analyze.readParams()
        par.printPar()

        rin_ref = str(rin + 0.3)

        setup.problemSetupDust('ppdisk',
                               tstar=tstar,
                               rstar=rstar,
                               nx=nx,
                               nz=nz,
                               xbound=f'[{str(rin)}*au, {rin_ref}*au, {rdisk1}*au]',
                               xres_nstep=xres_nstep,
                               xres_nspan=xres_nspan,
                               xres_nlev=xres_nlev,
                               sigma_type=sigma_type,
                               rin=str(rin) + '*au',
                               rdisk=str(rdisk1) + '*au',
                               plsig1=plsig1,
                               plh=plh,
                               mdisk=str(mdisk1) + '*ms',
                               scattering_mode_max=scattering_mode_max,
                               nphot=nphot,
                               nphot_scat=nphot_scat,
                               nphot_spec=nphot_spec,
                               dustkappa_ext = f"['{composition_name}']",
                               binary=binary,
                               nw=nw,
                               wbound=wbound)


        data = analyze.readData(ddens=True)
       
        c = plt.contourf(data.grid.x/natconst.au,np.pi/2.-data.grid.y,np.log10(data.rhodust[:,:,0,0].T),30)
        # c= plt.contourf(data.grid.x/natconst.au,np.pi/2.-data.grid.y,np.log10(data.rhodust[:,:,0,1].T),30)
        plt.xlabel('r[AU]')
        plt.ylabel(r'$\pi/2 - \theta$')
        plt.xscale('log')
        cb = plt.colorbar(c, pad=0.2)
        plt.title(f"Density map of {sim_name}")
        cb.set_label(r'$log_{10}{\rho}$', rotation=270., labelpad=15)
        plt.savefig( f"{sim_name}_density.png")  # Save figure in output directory
        plt.close()
        
        ##### everything else is commented here for running the code faster and testing things
        
        data.getTau(wav=nlmin)
        mid=len(data.grid.y)//2
        plt.figure()
        c=plt.contourf(data.grid.x/natconst.au, np.pi/2. -data.grid.y[0:mid],np.log10(data.tauy[:,0:mid,0].T),30,cmap='hot_r')
        plt.xlabel(r'$\mathrm{r\,[AU]}$')
        plt.ylabel(r'$\mathrm{\pi/2-\theta}$')
        plt.xscale('log')
        cb=plt.colorbar(c,pad=0.02)
        cb.set_label(r'$\mathrm{log_{10}{\tau}}$', rotation=270., labelpad=15)
        c=plt.contour(data.grid.x/natconst.au, np.pi/2. -data.grid.y[0:42], np.log10(data.tauy[:,0:42,0].T),[-5,0,1], colors='w',linestyles='solid' )
        plt.clabel(c,inline=1,fontsize=13)
       # plt.axvline(rdisk1,linestyle='--', color='k', alpha =0.2)
       # plt.axvline(rout,linestyle='--', color='k', alpha =0.2)
        plt.title(r'Optical depth distribution at $\lambda=8\mu m$')
        plt.savefig( f"{sim_name}_vertical_optical_depth.png")  # Save figure in output directory
        plt.close()
        
        plt.figure()
        c=plt.contourf(data.grid.x/natconst.au, np.pi/2. -data.grid.y,np.log10(data.taux[:,:,0].T),30,cmap='hot_r')
        plt.xlabel(r'$\mathrm{r\,[AU]}$')
        plt.ylabel(r'$\mathrm{\pi/2-\theta}$')
        plt.xscale('log')
        cb=plt.colorbar(c,pad=0.02)
        cb.set_label(r'$\mathrm{log_{10}{\tau}}$', rotation=270., labelpad=15)
        c=plt.contour(data.grid.x/natconst.au, np.pi/2. -data.grid.y, np.log10(data.taux[:,:,0].T),[-10,-8,-7, -5], colors='w',linestyles='solid' )
        plt.clabel(c,inline=1,fontsize=13)
        plt.title(r'Optical depth distribution at $\lambda=8\mu m$')
        plt.savefig( f"{sim_name}_radial_optical_depth.png")  # Save figure in output directory
        plt.close()
        
        os.system(f'taskset -c {core_range} bash -c "radmc3d setthreads 1; radmc3d mctherm"')
       
        
        data = analyze.readData(dtemp=True, binary=False)   
        plt.figure()
        c=plt.contourf(data.grid.x/natconst.au,np.pi/2.-data.grid.y,data.dusttemp[:,:,0,0].T,30)
        # c=plt.contourf(data.grid.x/natconst.au,np.pi/2.-data.grid.y,data.dusttemp[:,:,0,1].T,30)
        plt.xlabel('r [AU]')
        plt.ylabel(r'$\pi/2-\theta$')
        plt.xscale('log')
        cb = plt.colorbar(c)
        c=plt.contour(data.grid.x/natconst.au, np.pi/2. -data.grid.y,data.dusttemp[:,:,0,0].T, 10, colors='k',linestyles='solid' )
        plt.clabel(c,inline=1,fontsize=8)
        plt.title(f"temperature map of {sim_name}")
        cb.set_label('T [K]', rotation=270.)
        plt.savefig( f"{sim_name}_temperature.png")  # Save figure in output directory
        plt.close()
        
        os.system(f'taskset -c {core_range} bash -c "radmc3d setthreads 1; radmc3d sed incl {inc} sloppy"')
        # # os.system('radmc3d sed incl 30 sloppy setthreads 4')
        spec = analyze.readSpectrum(fname='spectrum.out')
        star = analyze.readStars()
        g    = analyze.readGrid()
        
        palette = sns.color_palette("rocket_r")
        colors = palette.as_hex()  # Convert to hex for Matplotlib
        plt.figure()
        analyze.plotSpectrum(a=spec, nufnu=True, micron=True, xlg=True, ylg=True, dpc=dpc, oplot=True,color = colors[4], label=f'SED for {sim_name}')
        flux = star.fnustar/((dpc)**2)
        flux = np.reshape(flux, len(spec))
        wavelength_range = np.array([3200, 13000]) * 1.e-3  # in micrometers
        wavelength_range=np.array([2800,5000,8000,13000])*1.e-3 #in nm*1e-3 i.e. micrometre
        plt.axvspan(wavelength_range[0], wavelength_range[1],alpha=0.3, color=colors[3], label=r'MATISSE $\lambda_{L,M}$ range')
        plt.axvspan(wavelength_range[2], wavelength_range[3],alpha=0.3, color=colors[5], label=r'MATISSE $\lambda_{N}$ range')
        plt.plot(g.wav, g.freq*flux, label='Stellar contribution')
        plt.xlabel(r'$\lambda$ [$\mu$m]')
        plt.ylabel(r'$\lambda f_{\lambda}$ [erg.$s^{-1}.cm^{-2}$]')
        plt.xlim(0.1, 1000.0)
        plt.xscale('log')
        plt.yscale('log')
        plt.grid()
        plt.legend()
        plt.savefig( f"{sim_name}_SED.png")  # Save figure in output directory
        plt.close()
       
        
        os.system(f'taskset -c {core_range} bash -c "radmc3d image npix {npix} incl {inc} sizeau {sizeau} lambdarange {nlmin} {nlmax} nlam {nlam} sloppy setthreads 1"')
       
        os.rename('image.out', f'test_{sim_name}_{inc}_{nlmin}_{nlmax}_band.out')
       
        im_test = image.readImage(fname=f'test_{sim_name}_{inc}_{nlmin}_{nlmax}_band.out')
       
        wavelength = nlmin
        keywords={'CRPIX1' : int(npix/2) , 'C|RPIX2': int(npix/2) , 'CRVAL1' : 0.0 , 'CRVAL2' : 0.0 , 'CUNIT3' : 'MICRON' , 'CRVAL3' : wavelength , 'CDELT3' :Cdelt3}
        im_test.writeFits(f'test_{sim_name}_{inc}_{nlmin}_{nlmax}_band.fits', dpc =dpc, fitsheadkeys=keywords)
    finally:
        os.chdir(original_dir)
#########################################################################################################################################################################
#########################################################################################################################################################################
# disk with gaps
#########################################################################################################################################################################
#########################################################################################################################################################################

def gap(sim_name, rin, rdisk1, rout, rdisk2, mdisk1, mdisk2, output_dir, core_range,
        tstar, rstar, inc, npix, sizeau, nlmin, nlmax, nlam, Cdelt3, dpc, composition_name, template_dir,
        optional_params_inner=None, optional_params_outer=None):

    if optional_params_inner is None:
        optional_params_inner = {}
    if optional_params_outer is None:
        optional_params_outer = {}

    # Common parameters (same for both disks)
    common_keys = {'nx', 'nz', 'xres_nstep', 'xres_nspan', 'xres_nlev',
                   'sigma_type', 'scattering_mode_max', 'nphot', 'nphot_scat',
                   'nphot_spec', 'binary', 'nw', 'wbound'}

    # Disk-specific parameters (can be different)
    disk_specific_keys = {'plsig1', 'plh'}

    for key in optional_params_inner:
        if key not in common_keys and key not in disk_specific_keys:
            raise ValueError(f"Inner disk optional parameter '{key}' is not recognized.")

    for key in optional_params_outer:
        if key not in common_keys and key not in disk_specific_keys:
            raise ValueError(f"Outer disk optional parameter '{key}' is not recognized.")

    # Extract common parameters
    nx = optional_params_inner.get('nx', '[100, 100, 100, 100]')
    nz = optional_params_inner.get('nz', '0')
    xres_nstep = optional_params_inner.get('xres_nstep', '3')
    xres_nspan = optional_params_inner.get('xres_nspan', '3')
    xres_nlev = optional_params_inner.get('xres_nlev', '3')
    sigma_type = optional_params_inner.get('sigma_type', '0')
    scattering_mode_max = optional_params_inner.get('scattering_mode_max', '1')
    nphot = optional_params_inner.get('nphot', '1e6')
    nphot_scat = optional_params_inner.get('nphot_scat', '1e6')
    nphot_spec = optional_params_inner.get('nphot_spec', '10000')
    # dustkappa_ext = optional_params_inner.get('dustkappa_ext', "['full_astrosil_amira']")
    binary = optional_params_inner.get('binary', False)
    nw = optional_params_inner.get('nw', '[10,40,30,20]')
    wbound = optional_params_inner.get('wbound', '[0.1, 1.0, 10., 25., 1e3]')

    # Disk-specific parameters
    plsig1_inner = optional_params_inner.get('plsig1', '-1')
    plh_inner = optional_params_inner.get('plh', '1./7.')

    plsig1_outer = optional_params_outer.get('plsig1', '-1')
    plh_outer = optional_params_outer.get('plh', '1./7.')

    original_dir = os.getcwd()
    os.makedirs(output_dir, exist_ok=True)

    # template_dir = f"{template_dir}"
    file_to_copy = f"dustkappa_{composition_name}.inp"
    src_file = os.path.join(template_dir, file_to_copy)

    if not os.path.isdir(template_dir):
        raise ValueError(f"Template directory '{template_dir}' does not exist.")
    
    if os.path.isfile(src_file):
        shutil.copy(src_file, output_dir)
    else:
        print(f"Warning: {file_to_copy} not found in {template_dir}")


    log_path = os.path.join(output_dir, "log.txt")
    with open(log_path, "w") as log_file:
        log_file.write(f"Simulation: {sim_name}\n")
        log_file.write(f"rin: {rin}, rdisk1: {rdisk1}, rout: {rout}, rdisk2: {rdisk2}, mdisk1: {mdisk1}, mdisk2:{mdisk2}, tstar:{tstar}, rstar:{rstar}, inc:{inc}, npix:{npix}, sizeau:{sizeau}, nlmin:{nlmin}, nlmax:{nlmax}, nlam:{nlam}\n")
        log_file.write(f"core_range: {core_range}\n")

    os.chdir(output_dir)

    try:
        models.getModelNames()
        models.getModelDesc('ppdisk')
        analyze.writeDefaultParfile('ppdisk')
        par = analyze.readParams()

        rin_ref = str(rin + 0.3)
        rout_ref = str(rout + 0.2)

        # Setup inner disk
        setup.problemSetupDust('ppdisk',
                               tstar=tstar,
                               rstar=rstar,
                               nx=nx,
                               nz=nz,
                               xbound=f'[{str(rin)}*au, {rin_ref}*au, {rout}*au, {rout_ref}*au, {rdisk2}*au]',
                               xres_nstep=xres_nstep,
                               xres_nspan=xres_nspan,
                               xres_nlev=xres_nlev,
                               sigma_type=sigma_type,
                               rin=str(rin) + '*au',
                               rdisk=str(rdisk1) + '*au',
                               plsig1=plsig1_inner,
                               plh=plh_inner,
                               mdisk=str(mdisk1) + '*ms',
                               scattering_mode_max=scattering_mode_max,
                               nphot=nphot,
                               nphot_scat=nphot_scat,
                               nphot_spec=nphot_spec,
                               binary=binary,
                               nw=nw,
                               wbound=wbound)
        par = analyze.readParams()
        par.printPar()
        data = analyze.readData(ddens=True)
        os.system('mv dust_density.inp  dust_density_inn.inp')
        with open('dust_density_inn.inp', 'r') as f:
            in_dens = np.loadtxt(f)
            count = int(in_dens[1])
            f.close()
        print('count = ',count)

        # Setup outer disk
        setup.problemSetupDust('ppdisk',
                               tstar=tstar,
                               rstar=rstar,
                               nx=nx,
                               nz=nz,
                               xbound=f'[{str(rin)}*au, {rin_ref}*au, {rout}*au, {rout_ref}*au, {rdisk2}*au]',
                               xres_nstep=xres_nstep,
                               xres_nspan=xres_nspan,
                               xres_nlev=xres_nlev,
                               sigma_type=sigma_type,
                               rin=str(rout) + '*au',
                               rdisk=str(rdisk2) + '*au',
                               plsig1=plsig1_outer,
                               plh=plh_outer,
                               mdisk=str(mdisk2) + '*ms',
                               scattering_mode_max=scattering_mode_max,
                               nphot=nphot,
                               nphot_scat=nphot_scat,
                               nphot_spec=nphot_spec,
                               binary=binary,
                               nw=nw,
                               wbound=wbound)

        par = analyze.readParams()
        par.printPar()
        data = analyze.readData(ddens=True)
       
        os.system('mv dust_density.inp dust_density_out.inp')
        with open('dust_density_out.inp', 'r') as f:
            out_dens = np.loadtxt(f)
            count = int(out_dens[1])
            f.close()
        print('count = ',count)

        Dust_dens = np.append(in_dens[3:len(in_dens)],out_dens[3:len(out_dens)])
        with open('dust_density.inp', 'w+') as f:
              f.write('1\n')
              f.write('%d\n'%(count))
              f.write('2\n')                          ##When considering both species 1 needs to be changed to 2
              np.savetxt(f, Dust_dens, fmt=['%13.6e'])  #When considering both species 'Sil_dens' needs to be changed to 'Dust_dens'
              f.close()
              
        with open('dustopac.inp','w+') as f:
            f.write('2            Format number of this file\n')
            f.write('2              Nr of dust species\n')   ##When considering both species 1 needs to be changed to 2
            f.write('============================================================================\n')
            f.write('1               Way in which this dust species is read\n')
            f.write('0               0=Thermal grain\n')
            f.write(f'{composition_name}      Extension of name of dustkapscatmat_***.inp file\n')
            f.write('============================================================================\n')
            f.write('1               Way in which this dust species is read\n')
            f.write('0               0=Thermal grain\n')
            f.write(f'{composition_name}      Extension of name of dustkapscatmat_***.inp file\n')
            f.write('----------------------------------------------------------------------------\n')
            
            #density plot

        data = analyze.readData(ddens=True)

        c = plt.contourf(data.grid.x/natconst.au,np.pi/2.-data.grid.y,np.log10(data.rhodust[:,:,0,0].T + data.rhodust[:,:,0,1].T),30)
        # c= plt.contourf(data.grid.x/natconst.au,np.pi/2.-data.grid.y,np.log10(data.rhodust[:,:,0,1].T),30)
        plt.xlabel('r[AU]')
        plt.ylabel(r'$\pi/2 - \theta$')
        plt.xscale('log')
        cb = plt.colorbar(c, pad=0.2)
        plt.title(f"Density map of {sim_name}")
        cb.set_label(r'$log_{10}{\rho}$', rotation=270., labelpad=15)
        plt.savefig( f"{sim_name}_density.png")  # Save figure in output directory
        plt.close()
        
        ##### everything else is commented here for running the code faster and testing things
        
        data.getTau(wav=2.5)
        mid=len(data.grid.y)//2
        plt.figure()
        c=plt.contourf(data.grid.x/natconst.au, np.pi/2. -data.grid.y[0:mid],np.log10(data.tauy[:,0:mid,0].T),30,cmap='hot_r')
        plt.xlabel(r'$\mathrm{r\,[AU]}$')
        plt.ylabel(r'$\mathrm{\pi/2-\theta}$')
        plt.xscale('log')
        cb=plt.colorbar(c,pad=0.02)
        cb.set_label(r'$\mathrm{log_{10}{\tau}}$', rotation=270., labelpad=15)
        c=plt.contour(data.grid.x/natconst.au, np.pi/2. -data.grid.y[0:42], np.log10(data.tauy[:,0:42,0].T),[-5,0,1], colors='w',linestyles='solid' )
        plt.clabel(c,inline=1,fontsize=13)
        plt.axvline(rdisk1,linestyle='--', color='k', alpha =0.2)
        plt.axvline(rout,linestyle='--', color='k', alpha =0.2)
        plt.title(r'Optical depth distribution at $\lambda=8\mu m$')
        plt.savefig( f"{sim_name}_vertical_optical_depth.png")  # Save figure in output directory
        plt.close()
        
        plt.figure()
        c=plt.contourf(data.grid.x/natconst.au, np.pi/2. -data.grid.y,np.log10(data.taux[:,:,0].T),30,cmap='hot_r')
        plt.xlabel(r'$\mathrm{r\,[AU]}$')
        plt.ylabel(r'$\mathrm{\pi/2-\theta}$')
        plt.xscale('log')
        cb=plt.colorbar(c,pad=0.02)
        cb.set_label(r'$\mathrm{log_{10}{\tau}}$', rotation=270., labelpad=15)
        c=plt.contour(data.grid.x/natconst.au, np.pi/2. -data.grid.y, np.log10(data.taux[:,:,0].T),[-10,-8,-7, -5], colors='w',linestyles='solid' )
        plt.clabel(c,inline=1,fontsize=13)
        plt.title(r'Optical depth distribution at $\lambda=8\mu m$')
        plt.savefig( f"{sim_name}_radial_optical_depth.png")  # Save figure in output directory
        plt.close()
        
        os.system(f'taskset -c {core_range} bash -c "radmc3d setthreads 1; radmc3d mctherm"')
      
        
        data = analyze.readData(dtemp=True, binary=False)   
        plt.figure()
        c=plt.contourf(data.grid.x/natconst.au,np.pi/2.-data.grid.y,data.dusttemp[:,:,0,0].T,30)
        # c=plt.contourf(data.grid.x/natconst.au,np.pi/2.-data.grid.y,data.dusttemp[:,:,0,1].T,30)
        plt.xlabel('r [AU]')
        plt.ylabel(r'$\pi/2-\theta$')
        plt.xscale('log')
        cb = plt.colorbar(c)
        c=plt.contour(data.grid.x/natconst.au, np.pi/2. -data.grid.y,data.dusttemp[:,:,0,0].T, 10, colors='k',linestyles='solid' )
        plt.clabel(c,inline=1,fontsize=8)
        plt.title(f"temperature map of {sim_name}")
        cb.set_label('T [K]', rotation=270.)
        plt.savefig( f"{sim_name}_temperature.png")  # Save figure in output directory
        plt.close()
        
        os.system(f'taskset -c {core_range} bash -c "radmc3d setthreads 1; radmc3d sed incl {inc} sloppy"')
        # # os.system('radmc3d sed incl 30 sloppy setthreads 4')
        spec = analyze.readSpectrum(fname='spectrum.out')
        star = analyze.readStars()
        g    = analyze.readGrid()
        
        palette = sns.color_palette("rocket_r")
        colors = palette.as_hex()  # Convert to hex for Matplotlib
        plt.figure()
        analyze.plotSpectrum(a=spec, nufnu=True, micron=True, xlg=True, ylg=True, dpc=dpc, oplot=True,color = colors[4], label=f'SED for {sim_name}')
        flux = star.fnustar/((dpc)**2)
        flux = np.reshape(flux, len(spec))
        wavelength_range = np.array([3200, 13000]) * 1.e-3  # in micrometers
        wavelength_range=np.array([2800,5000,8000,13000])*1.e-3 #in nm*1e-3 i.e. micrometre
        plt.axvspan(wavelength_range[0], wavelength_range[1],alpha=0.3, color=colors[3], label=r'MATISSE $\lambda_{L,M}$ range')
        plt.axvspan(wavelength_range[2], wavelength_range[3],alpha=0.3, color=colors[5], label=r'MATISSE $\lambda_{N}$ range')
        plt.plot(g.wav, g.freq*flux, label='Stellar contribution')
        plt.xlabel(r'$\lambda$ [$\mu$m]')
        plt.ylabel(r'$\lambda f_{\lambda}$ [erg.$s^{-1}.cm^{-2}$]')
        plt.xlim(0.1, 1000.0)
        plt.xscale('log')
        plt.yscale('log')
        plt.grid()
        plt.legend()
        plt.savefig( f"{sim_name}_SED.png")  # Save figure in output directory
        plt.close()

    
        os.system(f'taskset -c {core_range} bash -c "radmc3d image npix {npix} incl {inc} sizeau {sizeau} lambdarange {nlmin} {nlmax} nlam {nlam} sloppy setthreads 1"')

        os.rename('image.out', f'test_{sim_name}_{inc}_{nlmin}_{nlmax}_band.out')

        im_test = image.readImage(fname=f'test_{sim_name}_{inc}_{nlmin}_{nlmax}_band.out')

        wavelength = nlmin
        keywords={'CRPIX1' : int(npix/2) , 'C|RPIX2': int(npix/2) , 'CRVAL1' : 0.0 , 'CRVAL2' : 0.0 , 'CUNIT3' : 'MICRON' , 'CRVAL3' : wavelength , 'CDELT3' :Cdelt3}
        im_test.writeFits(f'test_{sim_name}_{inc}_{nlmin}_{nlmax}_band.fits', dpc =dpc, fitsheadkeys=keywords)

    
        
    finally:
        # Return to original directory
        os.chdir(original_dir)


#########################################################################################################################################################################
#########################################################################################################################################################################
# disk with cavity
#########################################################################################################################################################################
#########################################################################################################################################################################

def cavity(sim_name, rin, rout, rdisk, mdisk1, output_dir, core_range,
           tstar, rstar, inc, npix, sizeau, nlmin, nlmax, nlam, Cdelt3, dpc, composition_name, template_dir,
           optional_params=None):
    if optional_params is None:
        optional_params = {}

    allowed_keys = {'nx', 'nz', 'xres_nstep', 'xres_nspan', 'xres_nlev', 'sigma_type',
                    'plsig1', 'plh', 'scattering_mode_max', 'nphot', 'nphot_scat',
                    'nphot_spec', 'dustkappa_ext', 'binary', 'nw', 'wbound'}

    for key in optional_params:
        if key not in allowed_keys:
            raise ValueError(f"Optional parameter '{key}' is not recognized by the setup.")

    nx = optional_params.get('nx', '[100, 100, 100]')
    nz = optional_params.get('nz', '0')
    xres_nstep = optional_params.get('xres_nstep', '3')
    xres_nspan = optional_params.get('xres_nspan', '3')
    xres_nlev = optional_params.get('xres_nlev', '3')
    sigma_type = optional_params.get('sigma_type', '0')
    plsig1 = optional_params.get('plsig1', '-1')
    plh = optional_params.get('plh', '0')
    scattering_mode_max = optional_params.get('scattering_mode_max', '0')
    nphot = optional_params.get('nphot', '1e6')
    nphot_scat = optional_params.get('nphot_scat', '1e6')
    nphot_spec = optional_params.get('nphot_spec', '10000')
   # dustkappa_ext = optional_params.get('dustkappa_ext', "['full_astrosil_amira']")
    binary = optional_params.get('binary', False)
    nw = optional_params.get('nw', '[10,40,30,20]')
    wbound = optional_params.get('wbound', '[0.1, 1.0, 10., 25., 1e3]')

    original_dir = os.getcwd()
    os.makedirs(output_dir, exist_ok=True)

    # template_dir = "/data/users/abo/test_radmc"
    file_to_copy = f"dustkappa_{composition_name}.inp"
    src_file = os.path.join(template_dir, file_to_copy)

    if not os.path.isdir(template_dir):
        raise ValueError(f"Template directory '{template_dir}' does not exist.")
    
    if os.path.isfile(src_file):
        shutil.copy(src_file, output_dir)
    else:
        print(f"Warning: {file_to_copy} not found in {template_dir}")



    log_path = os.path.join(output_dir, "log.txt")
    with open(log_path, "w") as log_file:
        log_file.write(f"Simulation: {sim_name}\n")
        log_file.write(f"rin: {rin}, rout: {rout}, rdisk: {rdisk}, mdisk1: {mdisk1}, tstar:{tstar}, rstar:{rstar}, inc:{inc}, npix:{npix}, sizeau:{sizeau}, nlmin:{nlmin}, nlmax:{nlmax}, nlam:{nlam}\n")
        log_file.write(f"core_range: {core_range}\n")

    os.chdir(output_dir)

    try:
        models.getModelNames()
        models.getModelDesc('ppdisk')
        analyze.writeDefaultParfile('ppdisk')
        par = analyze.readParams()
        par.printPar()

        rout_ref = str(rout + 0.3)

        setup.problemSetupDust('ppdisk',
                               tstar=tstar,
                               rstar=rstar,
                               nx=nx,
                               nz=nz,
                               xbound=f'[{str(rin)}*au, {rout}*au, {rout_ref}*au, {rdisk}*au]',
                               xres_nstep=xres_nstep,
                               xres_nspan=xres_nspan,
                               xres_nlev=xres_nlev,
                               sigma_type=sigma_type,
                               rin=str(rout) + '*au',
                               rdisk=str(rdisk) + '*au',
                               plsig1=plsig1,
                               plh=plh,
                               mdisk=str(mdisk1) + '*ms',
                               scattering_mode_max=scattering_mode_max,
                               nphot=nphot,
                               nphot_scat=nphot_scat,
                               nphot_spec=nphot_spec,
                               dustkappa_ext = f"['{composition_name}']",
                               binary=binary,
                               nw=nw,
                               wbound=wbound)

       
            
            #density plot

        data = analyze.readData(ddens=True)

        c = plt.contourf(data.grid.x/natconst.au,np.pi/2.-data.grid.y,np.log10(data.rhodust[:,:,0,0].T),30)
        # c= plt.contourf(data.grid.x/natconst.au,np.pi/2.-data.grid.y,np.log10(data.rhodust[:,:,0,1].T),30)
        plt.xlabel('r[AU]')
        plt.ylabel(r'$\pi/2 - \theta$')
        plt.xscale('log')
        cb = plt.colorbar(c, pad=0.2)
        plt.title(f"Density map of {sim_name}")
        cb.set_label(r'$log_{10}{\rho}$', rotation=270., labelpad=15)
        plt.savefig( f"{sim_name}_density.png")  # Save figure in output directory
        plt.close()
        
       
        
        data.getTau(wav=nlmin)
        mid=len(data.grid.y)//2
        plt.figure()
        c=plt.contourf(data.grid.x/natconst.au, np.pi/2. -data.grid.y[0:mid],np.log10(data.tauy[:,0:mid,0].T),30,cmap='hot_r')
        plt.xlabel(r'$\mathrm{r\,[AU]}$')
        plt.ylabel(r'$\mathrm{\pi/2-\theta}$')
        plt.xscale('log')
        cb=plt.colorbar(c,pad=0.02)
        cb.set_label(r'$\mathrm{log_{10}{\tau}}$', rotation=270., labelpad=15)
        c=plt.contour(data.grid.x/natconst.au, np.pi/2. -data.grid.y[0:42], np.log10(data.tauy[:,0:42,0].T),[-5,0,1], colors='w',linestyles='solid' )
        plt.clabel(c,inline=1,fontsize=13)
        plt.axvline(rdisk,linestyle='--', color='k', alpha =0.2)
        plt.axvline(rout,linestyle='--', color='k', alpha =0.2)
        plt.title(r'Optical depth distribution at $\lambda=8\mu m$')
        plt.savefig( f"{sim_name}_vertical_optical_depth.png")  # Save figure in output directory
        plt.close()
        
        plt.figure()
        c=plt.contourf(data.grid.x/natconst.au, np.pi/2. -data.grid.y,np.log10(data.taux[:,:,0].T),30,cmap='hot_r')
        plt.xlabel(r'$\mathrm{r\,[AU]}$')
        plt.ylabel(r'$\mathrm{\pi/2-\theta}$')
        plt.xscale('log')
        cb=plt.colorbar(c,pad=0.02)
        cb.set_label(r'$\mathrm{log_{10}{\tau}}$', rotation=270., labelpad=15)
        c=plt.contour(data.grid.x/natconst.au, np.pi/2. -data.grid.y, np.log10(data.taux[:,:,0].T),[-10,-8,-7, -5], colors='w',linestyles='solid' )
        plt.clabel(c,inline=1,fontsize=13)
        plt.title(r'Optical depth distribution at $\lambda=8\mu m$')
        plt.savefig( f"{sim_name}_radial_optical_depth.png")  # Save figure in output directory
        plt.close()
        
        os.system(f'taskset -c {core_range} bash -c "radmc3d setthreads 1; radmc3d mctherm"')
      
        
        data = analyze.readData(dtemp=True, binary=False)   
        plt.figure()
        c=plt.contourf(data.grid.x/natconst.au,np.pi/2.-data.grid.y,data.dusttemp[:,:,0,0].T,30)
        # c=plt.contourf(data.grid.x/natconst.au,np.pi/2.-data.grid.y,data.dusttemp[:,:,0,1].T,30)
        plt.xlabel('r [AU]')
        plt.ylabel(r'$\pi/2-\theta$')
        plt.xscale('log')
        cb = plt.colorbar(c)
        c=plt.contour(data.grid.x/natconst.au, np.pi/2. -data.grid.y,data.dusttemp[:,:,0,0].T, 10, colors='k',linestyles='solid' )
        plt.clabel(c,inline=1,fontsize=8)
        plt.title(f"temperature map of {sim_name}")
        cb.set_label('T [K]', rotation=270.)
        plt.savefig( f"{sim_name}_temperature.png")  # Save figure in output directory
        plt.close()
        
        os.system(f'taskset -c {core_range} bash -c "radmc3d setthreads 1; radmc3d sed incl {inc} sloppy"')
        # # os.system('radmc3d sed incl 30 sloppy setthreads 4')
        spec = analyze.readSpectrum(fname='spectrum.out')
        star = analyze.readStars()
        g    = analyze.readGrid()
        
        palette = sns.color_palette("rocket_r")
        colors = palette.as_hex()  # Convert to hex for Matplotlib
        plt.figure()
        analyze.plotSpectrum(a=spec, nufnu=True, micron=True, xlg=True, ylg=True, dpc=dpc, oplot=True,color = colors[4], label=f'SED for {sim_name}')
        flux = star.fnustar/((dpc)**2)
        flux = np.reshape(flux, len(spec))
        wavelength_range = np.array([3200, 13000]) * 1.e-3  # in micrometers
        wavelength_range=np.array([2800,5000,8000,13000])*1.e-3 #in nm*1e-3 i.e. micrometre
        plt.axvspan(wavelength_range[0], wavelength_range[1],alpha=0.3, color=colors[3], label=r'MATISSE $\lambda_{L,M}$ range')
        plt.axvspan(wavelength_range[2], wavelength_range[3],alpha=0.3, color=colors[5], label=r'MATISSE $\lambda_{N}$ range')
        plt.plot(g.wav, g.freq*flux, label='Stellar contribution')
        plt.xlabel(r'$\lambda$ [$\mu$m]')
        plt.ylabel(r'$\lambda f_{\lambda}$ [erg.$s^{-1}.cm^{-2}$]')
        plt.xlim(0.1, 1000.0)
        plt.xscale('log')
        plt.yscale('log')
        plt.grid()
        plt.legend()
        plt.savefig( f"{sim_name}_SED.png")  # Save figure in output directory
        plt.close()
   
        
        os.system(f'taskset -c {core_range} bash -c "radmc3d image npix {npix} incl {inc} sizeau {sizeau} lambdarange {nlmin} {nlmax} nlam {nlam} sloppy setthreads 1"')

        os.rename('image.out', f'test_{sim_name}_{inc}_{nlmin}_{nlmax}_band.out')

        im_test = image.readImage(fname=f'test_{sim_name}_{inc}_{nlmin}_{nlmax}_band.out')

        wavelength = nlmin
        keywords={'CRPIX1' : int(npix/2) , 'C|RPIX2': int(npix/2) , 'CRVAL1' : 0.0 , 'CRVAL2' : 0.0 , 'CUNIT3' : 'MICRON' , 'CRVAL3' : wavelength , 'CDELT3' :Cdelt3}
        im_test.writeFits(f'test_{sim_name}_{inc}_{nlmin}_{nlmax}_band.fits', dpc =dpc, fitsheadkeys=keywords)

    
        
    finally:
        # Return to original directory
        os.chdir(original_dir)
        
def run(
    model,
    tstar_rstar_list,
    mdisk1,
    Inc,
    npix,
    sizeau,
    nlmin,
    nlmax,
    nlam,
    Cdelt3,
    dpc,
    composition_name,
    template_dir,
    rout=None,
    rdisk2=None,
    mdisk2=None,
    rdisk1=None,
    rdisk=None,
    total_cores=None,
    cores_per_sim=1,
    optional_params=None,
    optional_params_inner=None,
    optional_params_outer=None):

    if model == 0:
        if rdisk2 is not None or mdisk2 is not None:
            raise ValueError("Model 0 (continuous disk) does not take 'rdisk2' or 'mdisk2'. Please remove them.")
        if rdisk1 is None:
            raise ValueError("Model 0 (continuous disk) requires rdisk1 (outer radius of he disk). Please provide it.")
    elif model == 1:
        if rdisk2 is None or mdisk2 is None or rout is None:
            raise ValueError("Model 1 (gapped disk) requires 'rdisk2', 'mdisk2' and 'rout'. Please provide them.")
    elif model == 2:
        if rdisk2 is not None or mdisk2 is not None:
            raise ValueError("Model 2 (cavity disk) does not take 'rdisk2' or 'mdisk2'. Please remove them.")
        if rout is None:
            raise ValueError("Model 2 (cavity disk) requires 'rout'. Please provide it.")
        if rdisk is None:
            raise ValueError("Model 2 (cavity disk) requires 'rdisk', please prodvide it.")
    else:
        raise ValueError("Invalid model. Use 0 for continuous disk, 1 for gapped disk, or 2 for cavity disk.")

    if model in [0, 2] and (optional_params_inner or optional_params_outer):
        print("Warning: 'optional_params_inner' and 'optional_params_outer' are ignored for model {}.".format(model))

    if model == 1 and optional_params:
        print("Warning: 'optional_params' is ignored for model 1 (gapped disk). Use 'optional_params_inner' and 'optional_params_outer' instead.")

    if isinstance(rout, (int, float)):
        rout = [rout]

    if total_cores is None:
        total_cores = os.cpu_count()

    base_core = 0
    core_assignments = []
    sim_params = []
    calc_values = []

    for tstar, rstar in tstar_rstar_list:
        temp = tstar.strip('[]').replace('.0', '')
        rad = rstar.strip('[]').replace('*rs', '')
        Lum_star = Luminosity(float(rad), float(temp))
        rin = round(np.sqrt((Lum_star / (16 * np.pi * sigma * 1500**4))) / au, 5)

        Out_R = rout
        r_lim = [round(5 * rin, 5), round(10 * rin, 5)]
        calc_values.append((rin, temp, r_lim))

        if model == 1:  # GAPPED DISK
            simulations = [
                (
                    f"Model_gap_rin_{rin}_rdisk1_{rdisk1}_rout_{rout_val}_inc_{inc}",
                    rin,
                    rdisk1,
                    rout_val,
                    rdisk2,
                    mdisk1,
                    mdisk2,
                    inc,
                    npix,
                    sizeau,
                    nlmin,
                    nlmax,
                    nlam,
                    Cdelt3,
                    dpc,
                    composition_name,
                    template_dir
                )
                for rout_val, rdisk1, inc in product(Out_R, r_lim, Inc)
                if rdisk1 < rout_val
            ]

            for sim_name, rin, rdisk1, rout_val, rdisk2, mdisk1, mdisk2, inc, npix, sizeau, nlmin, nlmax, nlam, Cdelt3, dpc, composition_name, template_dir in simulations:
                core_start = base_core
                core_end = (core_start + cores_per_sim - 1) % total_cores

                if core_end < core_start:
                    core_range = f"{core_start}-{core_end + total_cores}"
                else:
                    core_range = f"{core_start}-{core_end}"

                if core_end >= total_cores:
                    raise ValueError(f"Not enough cores available for simulation {sim_name}.")

                label = tstar.strip('[]').replace('.0', '')
                output_dir = f"run_{sim_name}_T{label}"
                core_range = f"{core_start}-{core_end}"

                sim_params.append((
                    sim_name, rin, rdisk1, rout_val, rdisk2,
                    mdisk1, mdisk2, output_dir, core_range, tstar, rstar, inc,
                    npix, sizeau, nlmin, nlmax, nlam, Cdelt3, dpc,
                    composition_name, template_dir
                ))

                core_assignments.append(
                    f"{sim_name} (T={tstar} K, R={rstar}, L={round(Lum_star / L_sun, 3)} L_Sun incl = {inc}) ran on cores {core_range}"
                )

                base_core = (core_end + 1) % total_cores

        elif model == 0:  # CONTINUOUS DISK
            simulations = [
                (
                    f"Model_nogap_rin_{rin}_rdisk_{rdisk1}_inc_{inc}",
                    rin,
                    rdisk1,
                    mdisk1,
                    inc,
                    npix,
                    sizeau,
                    nlmin,
                    nlmax,
                    nlam,
                    Cdelt3,
                    dpc,
                    composition_name,
                    template_dir
                )
                for inc in Inc
            ]

            for sim_name, rin, rdisk, mdisk1, inc, npix, sizeau, nlmin, nlmax, nlam, Cdelt3, dpc, composition_name, template_dir in simulations:
                core_start = base_core
                core_end = (core_start + cores_per_sim - 1) % total_cores

                if core_end < core_start:
                    core_range = f"{core_start}-{core_end + total_cores}"
                else:
                    core_range = f"{core_start}-{core_end}"

                if core_end >= total_cores:
                    raise ValueError(f"Not enough cores available for simulation {sim_name}.")

                label = tstar.strip('[]').replace('.0', '')
                output_dir = f"run_{sim_name}_T{label}"
                core_range = f"{core_start}-{core_end}"

                sim_params.append((
                    sim_name, rin, rdisk, mdisk1, output_dir, core_range,
                    tstar, rstar, inc, npix, sizeau, nlmin, nlmax, nlam, Cdelt3,
                    dpc, composition_name, template_dir
                ))

                core_assignments.append(
                    f"{sim_name} (T={tstar} K, R={rstar}, L={round(Lum_star / L_sun, 3)} L_Sun incl = {inc}) ran on cores {core_range}"
                )

                base_core = (core_end + 1) % total_cores

        elif model == 2:  # CAVITY DISK
            simulations = [
                (
                    f"Model_cavity_rout_{rout_val}_rdisk_{rdisk}_inc_{inc}",
                    rin,
                    rout_val,
                    rdisk,
                    mdisk1,
                    inc,
                    npix,
                    sizeau,
                    nlmin,
                    nlmax,
                    nlam,
                    Cdelt3,
                    dpc,
                    composition_name,
                    template_dir
                )
                for rout_val, inc in product(Out_R, Inc)
                
            ]

            for sim_name, rin, rout_val, rdisk, mdisk1, inc, npix, sizeau, nlmin, nlmax, nlam, Cdelt3, dpc, composition_name, template_dir in simulations:
                core_start = base_core
                core_end = (core_start + cores_per_sim - 1) % total_cores

                if core_end < core_start:
                    core_range = f"{core_start}-{core_end + total_cores}"
                else:
                    core_range = f"{core_start}-{core_end}"

                if core_end >= total_cores:
                    raise ValueError(f"Not enough cores available for simulation {sim_name}.")

                label = tstar.strip('[]').replace('.0', '')
                output_dir = f"run_{sim_name}_T{label}"
                core_range = f"{core_start}-{core_end}"

                sim_params.append((
                    sim_name, rin, rout_val, rdisk, mdisk1, output_dir, core_range,
                    tstar, rstar, inc, npix, sizeau, nlmin, nlmax, nlam,
                    Cdelt3, dpc, composition_name, template_dir
                ))

                core_assignments.append(
                    f"{sim_name} (T={tstar} K, R={rstar}, L={round(Lum_star / L_sun, 3)} L_Sun incl = {inc}) ran on cores {core_range}"
                )

                base_core = (core_end + 1) % total_cores

    with open(f"rin_values_model_{model}.txt", "w") as f:
        for rin, temp, r_lim in calc_values:
            f.write(f"T = {temp} K -> rin = {rin} au \n")

    with ProcessPoolExecutor(max_workers=total_cores) as executor:
        if model == 1:
            future_to_sim = {
                executor.submit(gap, *params, optional_params_inner=optional_params_inner, optional_params_outer=optional_params_outer): params
                for params in sim_params
            }
        elif model == 0:
            future_to_sim = {
                executor.submit(nogap, *params, optional_params=optional_params): params
                for params in sim_params
            }
        elif model == 2:
            future_to_sim = {
                executor.submit(cavity, *params, optional_params=optional_params): params
                for params in sim_params
            }

        for future in tqdm(as_completed(future_to_sim), total=len(future_to_sim), desc=f"Running simulations (model {model})"):
            try:
                future.result()
            except Exception as exc:
                print(f"Simulation failed with exception: {exc}")

    print(f"\nFinal Core Assignments for model {model}:")
    for entry in core_assignments:
        print(entry)

    with open(f"core_log_model_{model}.txt", "w") as f:
        for entry in core_assignments:
            f.write(entry + "\n")

    print("\nVerifying CPU usage (running processes on cores):")
    os.system("ps -eo pid,psr,comm | grep radmc3d")

